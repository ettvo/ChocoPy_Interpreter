package chocopy.pa2;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import com.fasterxml.jackson.annotation.JsonCreator;

import chocopy.common.analysis.AbstractNodeAnalyzer;
import chocopy.common.analysis.NodeAnalyzer;
import chocopy.common.analysis.SymbolTable;
import chocopy.common.analysis.types.*;
import chocopy.common.astnodes.*;
import java_cup.runtime.ComplexSymbolFactory.Location;

/**
 * All analyze functions of this file should return a type from chocopy.common.analysis.types.
 */

/**
 * Analyzes declarations to create a top-level symbol table.
 */
public class DeclarationAnalyzer extends AbstractNodeAnalyzer<Type> {

    /** Current symbol table.  Changes with new declarative region. */
    private VarTable<Type> sym = new VarTable<>();
    
    /** Global symbol table. */
    private final VarTable<Type> globals = sym;

    /** Receiver for semantic error messages. */
    private final Errors errors;

    /* Keeps track of scope level and class hierarchies. 
     * See: HierarchyTracker and VarTable for more.
     */
    private final HierarchyTracker htracker;

    /** Global "class". Non-null for testing purposes. */
    private final String globalClass = "0Global"; 

    TreeNode curr;

    public HierarchyTracker getHierarchyTracker() {
        return htracker;
    }

    /** A new declaration analyzer sending errors to ERRORS0. */
    public DeclarationAnalyzer(Errors errors0) {
        assert (sym != null);
        errors = errors0;
        htracker = new HierarchyTracker(sym);
        curr = htracker.getRoot();
        sym.setNode(htracker.getRoot());
    }

    /** Inserts an error message in NODE if there isn't one already.
     *  The message is constructed with MESSAGE and ARGS as for
     *  String.format. */
    private void err(Node node, String message, Object... args) {
        errors.semError(node, message, args);
    }

    public void symNullCheck(String funcNameString) {
        if (sym == null) {
            System.out.println("null sym on func in DeclAnalyze: [" + funcNameString + "]");
        }
    }

    public void symNullCheck(String funcNameString, Declaration d) {
        if (sym == null) {
            System.out.println("null sym on declaration in DeclAnalyze: [" + d + "] at " + funcNameString);
        }
    }


    @Override
    public Type analyze(Program program) {
        assert (sym != null);
        for (Declaration decl : program.declarations) {
            Identifier id = decl.getIdentifier();
            String name = id.name;

            Type type = decl.dispatch(this);
            if (type == null || decl instanceof ClassDef) {
                continue;
            }

            if (isInvalidName(name) || sym.declares(name)) {
                err(id,
                                "Duplicate declaration of identifier in same "
                                + "scope: %s",
                                name);
                id.setInferredType(type);
            }
            else if (!sym.declares(type.className()) && !isBuiltInType(type.className())) {
                err(id, "Invalid type annotation; there is no class named: %s", type.className());
                id.setInferredType(type);
            }
            else {
                id.setInferredType(type);
                sym.put(name, type);
            }
        }

        return null;
    }

    

    public void handleDeclarations(List<Declaration> declarations) {
        symNullCheck("handledecl in declAnalyze");
        for (Declaration d: declarations) {
            symNullCheck("handledecl in declAnalyze1, failed decl for [" + d.getIdentifier().name + "]");
            Type currDecl = d.dispatch(this); 
            symNullCheck("handledecl in declAnalyze2, failed decl for [" + d.getIdentifier().name + "]");
            if (currDecl != null) {
                String name = d.getIdentifier().name;
                // d.getIdentifier().setInferredType(currDecl);
                if (name != null) {
                    if (d instanceof VarDef) {
                        VarDef node = (VarDef)d;
                        String declType = currDecl.className();
                        if (isInvalidName(name) || sym.declares(name)) { //
                            err(d.getIdentifier(),
                                            "Duplicate declaration of identifier in same "
                                            + "scope: %s",
                                            name);
                            ((VarDef)d).value.setInferredType(Type.OBJECT_TYPE);
                            // node.value.setInferredType(ValueType.annotationToValueType(node.var.type));
                        } 
                        else if (!sym.declares(declType) && !isDeclaredType(declType)) {
                            err(d.getIdentifier(), "Invalid type annotation; there is no class named: %s", declType);
                            ((VarDef)d).value.setInferredType(Type.OBJECT_TYPE);
                            // node.value.setInferredType(ValueType.annotationToValueType(node.var.type));
                        }
                        else {
                            sym.put(name, currDecl);
                            node.value.setInferredType(ValueType.annotationToValueType(node.var.type));
                            // ((VarDef)d).value.setInferredType(currDecl);
                        }
                        symNullCheck("handledecl in declAnalyze5, failed decl for [" + d.getIdentifier().name + "]");
                    }
                    else if (d instanceof FuncDef) {
                        FuncDef node = (FuncDef)d;
                        Identifier funcName = node.name;
                        String funcNameString = funcName.name;
                        ArrayList<ValueType> params = new ArrayList<>();
                        VarTable<Type> newFunc = new VarTable<>(sym, true, funcNameString, true);
                        newFunc.setNode(sym.getNode());
                        sym.addToChildren(newFunc, funcNameString);
                        boolean needsSelfParam = isClassMethod();
                        ValueType returnType = ValueType.annotationToValueType(node.returnType);
                        for (int i = 0; i < node.params.size(); i += 1) {
                            params.add(ValueType.annotationToValueType(node.params.get(i).type));
                        }
                        FuncType ret;
                        if (node.params.size() == 0) {
                            ret = new FuncType(returnType);
                        }
                        else {
                            ret = new FuncType(params, returnType);
                        }
                        node.name.setInferredType(ret);
                        if (sym.declares(funcNameString) || isInvalidName(funcNameString)) {
                            err(funcName, "Duplicate declaration of identifier in same scope: %s", funcNameString);
                        } 
                        else if (!sym.declares(funcNameString) && !isInvalidName(funcNameString)) {
    
                            sym.put(funcNameString, currDecl); 
                        }
                        sym = newFunc;
                        for (int i = 0; i < node.params.size(); i += 1) {
                            TypedVar currVar = node.params.get(i);
                            if ((i > 0 && needsSelfParam) || !needsSelfParam) {
                                ValueType currType = ValueType.annotationToValueType(currVar.type);
                                if (isClassMethod() && i == 0) {
                                    continue;
                                }
                                if (newFunc.declares(currVar.identifier.name) || isInvalidName(currVar.identifier.name)) {
                                    err(currVar.identifier,
                                                    "Duplicate declaration of identifier in same "
                                                    + "scope: %s",
                                                    currVar.identifier.name);
                                }
                                else if (!newFunc.declares(currType.toString()) && !isDeclaredType(currType.toString())) {
                                    err(node.getIdentifier(), "Invalid type annotation; there is no class named: %s", currVar.identifier.name);
                                }
                                else {
                                    newFunc.put(currVar.identifier.name, currType);
                                }
                            }
                        }
                        symNullCheck("handledecl in declAnalyze3, failed decl for [" + d.getIdentifier().name + "]");
                        handleDeclarations(node.declarations);
                        symNullCheck("handledecl in declAnalyze4, failed decl for [" + d.getIdentifier().name + "]");
                        sym = newFunc.getParent();

                    }
                }
            }
            else {
                symNullCheck("handledecl in declAnalyze, failed decl for [" + d.getIdentifier().name + "]");
                d.getIdentifier().setInferredType(Type.OBJECT_TYPE);
            }
        
        }
    }

    /* For use when you need to track a className. In other words, this is for use with FuncDef to track the function name. */
    public void handleDeclarations(List<Declaration> declarations, String className) {
        assert (sym != null);
        int counter = 0;
        for (Declaration d: declarations) {
            Type currDecl = d.dispatch(this); 
            if (currDecl != null) {
                String name = d.getIdentifier().name;
                if (name.equals("self") && counter == 0) {
                    counter += 1;
                    break;
                }
                if (d instanceof FuncDef) {
                    FuncDef func = (FuncDef)d;
                    Identifier funcName = func.name;
                    String funcNameString = funcName.name;
                    TypedVar currVar = func.params.get(0);
                    String paramName = currVar.identifier.name;
                    TypeAnnotation currParamClass = currVar.type;
                    if (!paramName.equals("self") || !(currParamClass instanceof ClassType) || !(((ClassType)currVar.type).className.equals(className))) {  // get classvaluetype
                        err(d.getIdentifier(), "First parameter of the following method must be of the enclosing class: %s", funcNameString);
                    }
                    else {
                        sym.put(funcNameString, ValueType.annotationToValueType(func.returnType));
                    }
                }
            }
        }
    }

    @Override
    public Type analyze(VarDef node) {
        assert (sym != null);
        return node.value.setInferredType(ValueType.annotationToValueType(node.var.type));
    }

    @Override
    public Type analyze(ClassDef node) {
        assert (sym != null);
        // members: funcdef, classdef, globaldecl, nonlocaldecl, vardef
        // this is the only place that the classHierarchy in varTable and TypeChecker classHierarchies should be edited
        String className = node.name.name;
        ClassValueType curr = new ClassValueType(className);
        
        String superClass = node.superClass.name;
        TreeNode superClassNode = htracker.findClassNode(superClass, sym.getNode(), true, true);
        if (superClassNode == null) {
            superClassNode = htracker.findClassNode(superClass, htracker.getRoot(), false, true);
        }
        
        VarTable<Type> newFunc = new VarTable<Type>(sym, true, className, false);
        TreeNode newNode = new TreeNode(superClassNode, className, curr, false, newFunc); // sets parent as 
        newFunc.setNode(newNode);
        if (superClassNode != null) {
            superClassNode.addChild(newNode);
        }
        
        htracker.addClass(className);
        
        if (sym.declares(className) || isInvalidName(className)) {
            err(node.name,
                            "Duplicate declaration of identifier in same "
                            + "scope: %s",
                            className);
        }
        else {
            sym.put(className, curr); 
        }
        // here
        sym.put(className, curr);
        newFunc.put("self", curr);
        newFunc.put(className, Type.NONE_TYPE); // constructor
        newFunc.addToHierarchy(className); // ????????
        sym.addToChildren(newFunc, className);
        sym = newFunc;
        handleDeclarations(node.declarations); // check the vardefs
        // handleDeclarations(node.declarations, className); // check the function defs
        

        if (newFunc.getParent() == null) {
            err(node, "Return on global scope");
        }
        sym = newFunc.getParent(); // should never be null
        return curr; // set to null if it shows up too much on the symbol table
    }


    @Override
    public Type analyze(FuncDef node) {
        assert (sym != null);
        List<ValueType> params = new ArrayList<>();
        ValueType returnType = ValueType.annotationToValueType(node.returnType);
        String funcNameString = node.name.name;
        FuncType ret = null;
        if (node.params.size() == 0) {
            ret = new FuncType(returnType);
        }
        else {
            ret = new FuncType(params, returnType);
        }
        VarTable<Type> newFunc = new VarTable<Type>(sym, true, funcNameString, false);
        sym = newFunc;
        handleDeclarations(node.declarations);
        sym = newFunc.getParent();
        return ret;
    }
    
    @Override
    public Type analyze(GlobalDecl node) {
        assert (sym != null);
        Identifier id = node.getIdentifier();
        String name = id.name;
        VarTable<Type> globalTable = getGlobals();
        if (!globalTable.declares(name)) {
            err(node, "Global variable DNE: %s", name);
            return null; 
        }
        else if (globalTable.equals(sym)) {
            err(node, "Illegal declaration of global variable at global level: %s", name);
            return null; 
        } 
        else {
            return globalTable.get(name);
        }
    }

    @Override
    public Type analyze(NonLocalDecl node) {
        assert (sym != null);
        Identifier id = node.getIdentifier();
        String name = id.name;
        Type curr = sym.get(name); 
        VarTable<Type> globalTable = getGlobals();
        if (globalTable.declares(name)) {
            err(node, "Illegal global declaration of nonlocal variable: %s", name);
            return null; 
        }
        else if (sym.getParent() == null || sym.getParent().equals(globalTable)) {
            err(node, "Illegal declaration of nonlocal variable outside of nested function: %s", name);
            return null; 
        }
        else if (curr == null) {
            err(node, "Invalid nonlocal: %s", name);
            return null; 
        }
        return curr;
    }

    /** Helpers. */
    
    /* Returns True if SUB is a subset of SUPERSET. For use when checking entries of lists in analyze(AssignStmt node).
     * Ex: if SUPER is Type.OBJECT_TYPE, isSupersetType returns True for everything
     * Ex: if SUB is Type.NONE_TYPE returns True for every value of SUPER
     * For this, INT is NOT a subset of BOOL
    */
    public boolean isSupersetType(Type superset, Type subset) {
        Type superset_type = superset;
        Type subset_type = subset;

        if (superset == null) {
            return false;
        }
        else if (superset == null || subset == null) {
            return false;
        }
        if (superset.equals(subset)) {
            return true;
        }
        if (superset instanceof ListValueType || superset.isListType()) {
            superset_type = ((ListValueType)superset).elementType();
        }
        if (subset instanceof ListValueType || subset.isListType()) {
            subset_type = ((ListValueType)subset).elementType();
        }
        if (superset.isListType() && subset.isListType()) {
            if (subset_type.equals(superset_type)
            || (subset_type.equals(Type.EMPTY_TYPE) || subset_type.equals(Type.NONE_TYPE))) 
            {
                return true;
            }
        }
        else if ((superset.isListType() && !subset.isListType())) {
            if (superset_type.equals(subset) 
            || superset_type.equals(Type.OBJECT_TYPE)
            || subset.equals(Type.NONE_TYPE) 
            || subset.equals(Type.EMPTY_TYPE)) 
            {
                return true;
            }
        }
        else if (!superset.isListType() && subset.isListType()) {
            if (superset.equals(Type.OBJECT_TYPE)) {
                return true;
            }
        }
        else if (superset_type.equals(Type.OBJECT_TYPE)) {
            // subset being None is valid only if superset is Obj
            return true;
        }
        return false;
    }

    /* For use with GlobalDecl's analyze function. */
    public VarTable<Type> getGlobals() {
        return globals;
    }

    /* Used to check if the current FuncDef is part of a class and therefore needs the "self" param. 
     * Works by checking if the current symbol table is the global symbol table or not. 
    */
    public boolean isClassMethod() {
        return !globals.equals(sym);
    }

    public boolean isInvalidName(String name) {
        List<String> invalidNames = Arrays.asList("self", "int", "bool", "char", "def", "True", "False", "None", "and", "as", 
        "assert", "break", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", 
        "from", "global", "if", "import", "in", "is", "lambda", "nonlocal", "not", "or", "pass", "print", 
        "raise", "return", "try", "while", "with", "yield", "float", "id", "len", "max", "min", "pow", 
        "range", "round", "str", "type");
        if (invalidNames.contains(name)) {
            return true;
        }
        return false;
    }

    public boolean isBuiltInType(String name) {
        List<String> types = Arrays.asList("int", "bool", "char", "float", "str", "object", "<None>"); // "list"?
        if (types.contains(name) || name == null) { // returned when ValueType type.className() gives a null because of not being from a "class"
            return true;
        }
        return false;
    }

    public boolean isDeclaredType(String name) {
        return isBuiltInType(name) || htracker.getAllClasses().contains(name);
    }
}