import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class that performs
 * production-rule actions. */
action code {:

    /** Return a mutable list initially containing the single value ITEM. */
    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** If ITEM is non-null, appends it to the end of LIST.  Then returns
     *  LIST. */
    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Return a mutable empty list. */
    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    /** Return the leftmost non-whitespace location in NODES, or null if NODES
     *  is empty.  Assumes that the nodes of NODES are ordered in increasing
     *  order of location, from left to right. */
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    boolean allowDeclarations = true;
:}

/* Terminal symbols (tokens returned by the lexer).  The declaration
 *     terminal <identifier1>, <identifier2>, ...;
 * declares each <identifieri> as the denotation of a distinct type terminal
 * symbol for use in the grammar.  The declaration
 *     terminal <type> <identifier1>, ...;
 * does the same, and in addition indicates that the lexer supplies a
 * semantic value of type <type> for these symbols that may be referenced
 * in actions ( {: ... :} ).
 */
terminal NEWLINE;
terminal Integer INDENT;
terminal Integer DEDENT;
terminal DOT;
terminal RIGHTARROW;
terminal DEF;
terminal String COLON;
terminal String PLUS;
terminal Integer NUMBER; 
terminal String MINUS;
terminal String MULTIPLY;
terminal String MODULUS;
terminal String FLOORDIVISION; // //
terminal String ASSIGNMENT; // =
terminal String EXPONENT; // **
terminal String BOOLEANLITERALS;
terminal String NONELITERAL;
terminal String STRINGLITERAL;
terminal String LBRACKET; // [, lists and stuff
terminal String RBRACKET; // ]
terminal String LPARENTHESES;
terminal String RPARENTHESES;
terminal String COMMA;
terminal String IF;
terminal String ELIF;
terminal String ELSE;
terminal String NOT;
terminal String AND;
terminal String OR;
terminal String GT;
terminal String LT;
terminal String GTE;
terminal String LTE;
terminal String EQ;
terminal String IDENTIFIER;
terminal String WHILE;
terminal String FOR;
terminal String IN;
terminal String RETURN;
terminal String PASS;

/* Returned by the lexer for erroneous tokens.  Since it does not appear in
 * the grammar, it indicates a syntax error. */
// terminal UNRECOGNIZED;   
terminal String UNRECOGNIZED;   

/* Nonterminal symbols (defined in production rules below).
 * As for terminal symbols, 
 *     non terminal <type> <identifier1>, ..., <identifiern>; 
 * defines the listed nonterminal identifier symbols to have semantic values
 * of type <type>. */
non terminal Program           program;
non terminal List<Declaration> program_head, global_declarations, declaration_list;
non terminal List<Stmt>        stmt_list, opt_stmt_list, block;
non terminal Stmt              stmt, expr_stmt, while_stmt, for_stmt, elif_stmt;
non terminal Expr              expr, binary_expr, unary_expr, list_obj, if_inline;
non terminal IndexExpr         index_expr;
non terminal AssignStmt        assign_stmt;
non terminal MemberExpr        member_expr;
non terminal CallExpr          call_expr;
non terminal List<Expr>        list_contents;
non terminal Literal           literal;
non terminal Declaration       var_def, function;
non terminal TypedVar          param_def, typed_var;
non terminal List<TypedVar>    param_list;
non terminal IfStmt            if_stmt;


/* Precedences (lowest to highest) for resolving what would otherwise be
 * ambiguities in the form of shift/reduce conflicts.. */
precedence right IDENTIFIER;
precedence right NEWLINE, INDENT;
precedence right LBRACKET;
precedence left DEDENT, RBRACKET;
precedence left COLON;
precedence right ASSIGNMENT;

// precedence left ASSIGNMENT; 
precedence right EQ; 
precedence right EXPONENT;

// bitwise operators +, ~, etc.
precedence left MULTIPLY, MODULUS, FLOORDIVISION; // also, @, /
precedence left OR, AND, PLUS, MINUS, GT, LT, GTE, LTE;
precedence right IF, ELSE; // COLON, NEWLINE, DEDENT, INDENT
precedence right NOT; // guess
precedence right FOR, PASS, WHILE, LPARENTHESES, STRINGLITERAL, NONELITERAL, BOOLEANLITERALS, NUMBER;
precedence left RPARENTHESES; 

/* The start symbol. */
start with program;


/*****  GRAMMAR RULES *****/

program ::= 
        stmt_list:s
            {: RESULT = new Program(getLeft(s),
                                    sxright, empty(), s, errors);
            :}
        | program_head:d opt_stmt_list:s
            {: RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d),
                                    sxright, d, s, errors);
            :}
        ;



/* Initial list of declarations. */
program_head ::= /* not implemented; currently matches empty string */
                {: RESULT = empty(); :}
                | global_declarations:g {: RESULT = g; :}
                ;


var_def ::= 
        // probably confusion between assignment and this
        IDENTIFIER:e1 COLON:c IDENTIFIER:e2 ASSIGNMENT:a literal:e3 NEWLINE
            {:  
                // System.out.println("vardef");
                ClassType className = new ClassType(e2xleft, e2xright, e2); 
                Identifier name = new Identifier(e1xleft, e1xright, e1);
                TypedVar curr = new TypedVar(e1xleft, e2xright, name, className);
                RESULT = new VarDef(e1xleft, e3xright, curr, e3);
            :}
            // %prec NOT
        | INDENT IDENTIFIER:e1 COLON:c IDENTIFIER:e2 ASSIGNMENT:a literal:e3 DEDENT
            {:  
                ClassType className = new ClassType(e2xleft, e2xright, e2); 
                Identifier name = new Identifier(e1xleft, e1xright, e1);
                TypedVar curr = new TypedVar(e1xleft, e2xright, name, className);
                RESULT = new VarDef(e1xleft, e3xright, curr, e3);
            :}
    ;

global_declarations ::=
        var_def:v  {: RESULT = single(v); :}
        | function:f {: RESULT = single(f); :}
        | global_declarations:g error:e 
            {:
                System.out.println("here!");
                RESULT = g;
            :}
    ;

declaration_list ::=
        {: RESULT = empty(); :}
        | global_declarations:g {: RESULT = g; :}
        | global_declarations:g1 var_def:v {: RESULT = combine(g1, v); :}
    ;


param_list ::=
        {: RESULT = empty(); :}
        | IDENTIFIER:e1 COLON:c IDENTIFIER:e2 
            {: 
                ClassType className = new ClassType(e2xleft, e2xright, e2); 
                Identifier name = new Identifier(e1xleft, e1xright, e1);
                RESULT = single(new TypedVar(e1xleft, e2xright, name, className)); 
            :}
        | param_list:p1 COMMA IDENTIFIER:e1 COLON:c IDENTIFIER:e2 
            {:  ClassType className = new ClassType(e2xleft, e2xright, e2); 
                Identifier name = new Identifier(e1xleft, e1xright, e1);
                RESULT = combine(p1, new TypedVar(e1xleft, e2xright, name, className)); :}
    ;

opt_stmt_list ::=                    {: RESULT = empty(); :}
                | stmt_list:s        {: RESULT = s; :}
                                ;

stmt_list ::= 
            stmt:s                   {: RESULT = single(s); :}
            | PASS                   {: RESULT = empty(); :}
            | stmt_list:l PASS       {: RESULT = l; :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error:e      
                {: RESULT = l; 
                :}
            /* If there is a syntax error in the source, this says to discard
             * symbols from the parsing stack and perform reductions until
             * there is a stmt_list on top of the stack, and then to discard
             * input symbols until it is possible to shift again, reporting
             * a syntax error. */
            ;

stmt ::= // for function bodies and stuff
        expr_stmt:s NEWLINE         {: RESULT = s; :} 
        | assign_stmt:a NEWLINE     {: RESULT = a; :}
        | while_stmt:w      {: RESULT = w; :}
        | for_stmt:f        {: RESULT = f; :}
        | if_stmt:i         {: RESULT = i; :}
        | stmt:s NEWLINE            {: RESULT = s; :}
        | NEWLINE stmt:s            {: RESULT = s; :}
        | stmt:s UNRECOGNIZED:d 
                    {:   
                        System.out.println("error is: " + d); // here?
                        errors.add(new CompilerError(dxleft, dxright, d, false));
                        RESULT = s;
                    :}
        ;

while_stmt ::=
    WHILE:op expr:e COLON:c block:b DEDENT:d 
        {: 
            RESULT = new WhileStmt(opxleft, dxleft, e, b); 
        :}
    ;

if_stmt ::=
    IF:op expr:e COLON:c block:b DEDENT:d 
        {: 
            RESULT = new IfStmt(opxleft, dxleft, e, b, empty()); 
        :}  
    | IF:op expr:e COLON:c block:b DEDENT:d elif_stmt:el 
        {: 
            RESULT = new IfStmt(opxleft, elxleft, e, b, single(el));
        :} 
    | IF:op expr:e COLON:c block:b DEDENT:d ELSE COLON block:b2 DEDENT:d2
        {: 
            RESULT = new IfStmt(opxleft, dxleft, e, b, b2); 
        :}

    ;

elif_stmt ::= 
    ELIF:el expr:e COLON:c block:b DEDENT:d 
        {:
            RESULT = new IfStmt(elxleft, dxleft, e, b, empty());
        :}
    | ELIF:el expr:e COLON:c block:b DEDENT:d elif_stmt:chain
        {:
            RESULT = new IfStmt(elxleft, chainxleft, e, b, single(chain));
        :}
    | ELIF:el expr:e COLON:c block:b DEDENT:d ELSE COLON block:b2 DEDENT:d2
        {:
            RESULT = new IfStmt(elxleft, dxleft, e, b, b2);
        :}
    ;


for_stmt ::=
    FOR:op IDENTIFIER:id IN list_obj:l COLON:c block:b DEDENT:d 
        {:  
            Identifier x = new Identifier(idxleft, idxright, id);
            RESULT = new ForStmt(opxleft, dxleft, x, l, b);
        :}
    | FOR:op IDENTIFIER:id IN IDENTIFIER:l COLON:c block:b DEDENT:d 
        {:
            Identifier x1 = new Identifier(idxleft, idxright, id);
            Identifier x2 = new Identifier(lxleft, lxright, l);
            RESULT = new ForStmt(opxleft, dxleft, x1, x2, b);
        :}
    | FOR:op IDENTIFIER:id IN STRINGLITERAL:s COLON:c block:b DEDENT:d 
        {:
            Identifier x = new Identifier(idxleft, idxright, id);
            StringLiteral l = new StringLiteral(sxleft, sxright, s);
            RESULT = new ForStmt(opxleft, dxleft, x, l, b);
        :}
    ;

block ::= 
    INDENT stmt:s 
        {: 
            RESULT = single(s); 
        :}
    | INDENT expr_stmt:s 
        {: 
            RESULT = single(s); 
        :}
    | INDENT assign_stmt:a     {: RESULT = single(a); :}
    | INDENT RETURN:r expr:e 
        {: 
            RESULT = single(new ReturnStmt(rxleft, exright, e)); 
        :}
    | INDENT PASS:p  {: RESULT = empty(); :}
    | block:b INDENT stmt:s2 {: RESULT = combine(b, s2); :}
    | INDENT error:d 
        {:
            errors.add(new CompilerError(dxleft, dxright, "Indent/Dedent 1", true));
            RESULT = empty();
        :}
    | block:b error:d   
        {:
            errors.add(new CompilerError(dxleft, dxright, "Indent/Dedent 2", true));
            RESULT = b;
        :}
    ;

function ::=
    DEF:start IDENTIFIER:id LPARENTHESES param_list:p RPARENTHESES RIGHTARROW IDENTIFIER:rt COLON INDENT declaration_list:d DEDENT block:b DEDENT:end
        {:  Identifier funcName = new Identifier(idxleft, idxright, id);
            TypeAnnotation returnType = new ClassType(rtxleft, rtxright, rt);
            RESULT = new FuncDef(startxleft, endxleft, funcName, p, returnType, d, b);
        :}
    | DEF:start IDENTIFIER:id LPARENTHESES param_list:p RPARENTHESES RIGHTARROW IDENTIFIER:rt COLON block:b DEDENT:end
        {:  
            Identifier funcName = new Identifier(idxleft, idxright, id);
            TypeAnnotation returnType = new ClassType(rtxleft, rtxright, rt);
            RESULT = new FuncDef(startxleft, endxleft, funcName, p, returnType, empty(), b);
        :}
    ; 

expr_stmt ::= 
            expr:e    {: RESULT = new ExprStmt(exleft, exright, e); :}
            ;

expr ::= // inline stuff
        unary_expr:u                {: RESULT = u; :}
        | literal:l                 {: RESULT = l; :}
        | list_obj:ls               {: RESULT = ls; :}
        | index_expr:i              {: RESULT = i; :}
        | binary_expr:e             {: RESULT = e; :}
        | member_expr:m             {: RESULT = m; :}
        | if_inline:i               {: RESULT = i; :}
        | IDENTIFIER:i              {: RESULT = new Identifier(ixleft, ixright, i); :}
        | call_expr:c               {: RESULT = c; :}
        | LPARENTHESES expr:e RPARENTHESES {: RESULT = e; :}
       ;

call_expr ::=
        IDENTIFIER:id LPARENTHESES:l RPARENTHESES:r 
            {: 
                RESULT = new CallExpr(idxleft, idxright, new Identifier(idxleft, idxright, id), empty()); 
            :}   
        | IDENTIFIER:id LPARENTHESES:l expr:e RPARENTHESES:r 
            {:  
                RESULT = new CallExpr(idxleft, rxleft, new Identifier(idxleft, idxright, id), single(e)); 
            :} 
        | IDENTIFIER:id LPARENTHESES:l list_contents:ls RPARENTHESES:r 
            {:  
                RESULT = new CallExpr(idxleft, rxleft, new Identifier(idxleft, idxright, id), ls); 
            :} 
    ;

member_expr ::= 
        IDENTIFIER:i1 DOT IDENTIFIER:i2
            {:  Identifier obj = new Identifier(i1xleft, i1xright, i1);
                Identifier member = new Identifier(i2xleft, i2xright, i2);
                RESULT = new MemberExpr(i1xleft, i2xright, obj, member); :}
        ;

literal ::=
    NUMBER:n                    {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
    | BOOLEANLITERALS:b         {: RESULT = new BooleanLiteral(bxleft, bxright, Boolean.valueOf(b)); :}
    | NONELITERAL:none          {: RESULT = new NoneLiteral(nonexleft, nonexright); :}
    | STRINGLITERAL:s           {: RESULT = new StringLiteral(sxleft, sxright, s); :}
    ;

if_inline ::= 
            expr:e1 IF expr:e2 ELSE:op3 expr:e3 
                {: 
                    RESULT = new IfExpr(e1xleft, e1xright, e2, e1, e3); 
                :}
            ;

index_expr ::=
            IDENTIFIER:id LBRACKET:lb IDENTIFIER:e RBRACKET:rb
                    {:  // x[a] 
                        Expr idExpr = new Identifier(idxleft, idxright, id);
                        Expr indexExpr = new Identifier(exleft, exright, e);
                        RESULT = new IndexExpr(idxleft, rbxright, idExpr, indexExpr);
                    :}
            | IDENTIFIER:id LBRACKET:lb NUMBER:e RBRACKET:rb
                    {:  // x[a] 
                        Expr idExpr = new Identifier(idxleft, idxright, id);
                        Expr indexExpr = new IntegerLiteral(exleft, exright, e);
                        RESULT = new IndexExpr(idxleft, rbxright, idExpr, indexExpr);
                    :}
            | index_expr:id LBRACKET:lb IDENTIFIER:e RBRACKET:rb
                    {:  // x[a][a] or x[1][a]
                        Expr indexExpr = new Identifier(exleft, exright, e);
                        RESULT = new IndexExpr(idxleft, rbxright, id, indexExpr);
                    :}
            | index_expr:id LBRACKET:lb NUMBER:e RBRACKET:rb
                    {:  // x[a][a] or x[1][a]
                        Expr indexExpr = new IntegerLiteral(exleft, exright, e);
                        RESULT = new IndexExpr(idxleft, rbxright, id, indexExpr);
                    :}
    ;

assign_stmt ::=
            IDENTIFIER:id ASSIGNMENT:a expr:e2 
                {:  List<Expr> targets = single(new Identifier(idxleft, idxright, id));
                    RESULT = new AssignStmt(idxleft, e2xright, targets, e2); 
                :}
            | index_expr:i ASSIGNMENT:a expr:e2 
                {:  List<Expr> targets = single(i);
                    RESULT = new AssignStmt(ixleft, e2xright, targets, e2); 
                :}
            | member_expr:m ASSIGNMENT:a expr:e2 
                {:
                    List<Expr> targets = single(m);
                    RESULT = new AssignStmt(mxleft, e2xright, targets, e2);
                :}
            | IDENTIFIER:i ASSIGNMENT:a assign_stmt:a1 
                {:  
                    List<Expr> new_targets = single(new Identifier(ixleft, ixright, i));
                    new_targets.addAll(a1.targets);
                    RESULT = new AssignStmt(ixleft, a1xright, new_targets, a1.value); 
                :}
            | index_expr:i ASSIGNMENT:a assign_stmt:a1 
                {:
                    List<Expr> new_targets = single(i);
                    new_targets.addAll(a1.targets);
                    RESULT = new AssignStmt(ixleft, a1xright, new_targets, a1.value); 
                :}
            | member_expr:m ASSIGNMENT:a assign_stmt:a1 
                {:
                    List<Expr> new_targets = single(m);
                    new_targets.addAll(a1.targets);
                    RESULT = new AssignStmt(mxleft, a1xright, new_targets, a1.value);
                :}
            
    ;


list_contents ::= 
        literal:e1 COMMA:c literal:e2 
            {: 
                ArrayList<Expr> curr = new ArrayList<>();
                curr.add(e1);
                curr.add(e2);
                RESULT = curr;
            :}
        | list_contents:lc COMMA:c literal:e1 
            {:
                RESULT = combine(lc, e1);
            :}
    ;

list_obj ::=
            LBRACKET:lb RBRACKET:rb 
                {: 
                    RESULT = new ListExpr(lbxleft, rbxright, empty()); 
                :}
            | LBRACKET:lb literal:e RBRACKET:rb 
                {: 
                    RESULT = new ListExpr(lbxleft, rbxright, single(e)); 
                :}
            | LBRACKET:lb list_contents:lc RBRACKET:rb 
                {: 
                    RESULT = new ListExpr(lbxleft, rbxright, lc);
                :}
    ;

unary_expr ::=
        MINUS:op expr:u {: RESULT = new UnaryExpr(opxleft, uxright, op, u); :}
        | NOT:op expr:e1            {: RESULT =  new UnaryExpr(e1xleft, e1xright, op, e1); :}
    ;

/* A binary expression, illustrating how to find the left and right
 * source position of a phrase. */
binary_expr ::= 
                expr:e1 PLUS:op expr:e2
                        {:
                            RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 GT:op expr:e2 
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 LT:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 GTE:op expr:e2 
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 LTE:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 MINUS:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 MULTIPLY:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 MODULUS:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 FLOORDIVISION:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 EQ:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 EXPONENT:op expr:e2
                        {: RESULT = new BinaryExpr(e1xleft, e2xright,
                                                   e1, op, e2); :}
                | expr:e1 AND:op expr:e2    {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
                | expr:e1 OR:op expr:e2     {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}     
                // |
              ;